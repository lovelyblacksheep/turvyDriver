import React from "react";
import { StyleSheet, Text, View,Dimensions,Image,ScrollView ,TouchableOpacity,ActivityIndicator,BackHandler,StatusBar,Platform,Linking,Modal,TouchableHighlight,Animated} from 'react-native';
//import * as Permissions from 'expo-permissions';
import MapView , { Marker , Polyline ,Callout,Circle , AnimatedRegion}from 'react-native-maps';
import * as Location from 'expo-location';
import MapViewDirections from 'react-native-maps-directions';
import GooglePlacesInput from './GooglePlacesInput';
import { EvilIcons,Ionicons,MaterialCommunityIcons,FontAwesome5,Feather,AntDesign,Entypo } from '@expo/vector-icons'; 
const imagemarker = require('../assets/location-pin-2965.png');
const driversummy = require('../assets/driversummy.png');
const imageveh = require('../assets/images/driver-veh-images_60.png');
//import Animated from 'react-native-reanimated';
import BottomSheet from 'reanimated-bottom-sheet';
import { Button ,Badge} from 'react-native-paper';
import { Col, Row, Grid } from "react-native-easy-grid";
import AsyncStorage from '@react-native-async-storage/async-storage';
import FlashMessage , { showMessage, hideMessage }  from "react-native-flash-message";
const StatusBarheight = StatusBar.currentHeight+80;
import { Audio } from 'expo-av';
const { width, height } = Dimensions.get('window');
import CancelPop from './CancelPop';
import Pusher from 'pusher-js/react-native';
import TopBar from "./TopBar";

const ASPECT_RATIO = width / height;
const LATITUDE_DELTA = 0.0043;
const SCREENHEIGHT = height*.60;
const DEVICE_WIDTH = width;
const DEVICE_HEIGHT = height;		
//console.log("height");
//console.log(SCREENHEIGHT);

const stylesArray = [
  {
    "featureType": "road.highway",
    "stylers": [
      { "color": "#7E96BC" }
    ]
  },{
    "featureType": "road.arterial",
    "elementType": "geometry",
    "stylers": [
      { "color": "#FEFEFE" }
    ]
  },
	{
	"featureType": "water",
    "stylers": [
      { "color": "#8ABFE5"  }
    ]
	},
	{
	"featureType": "landscape.natural",
    "stylers": [
      { "color": "#EBECEF"  }
    ]
	},
	{
	"featureType": "landscape.natural.landcover",
    "stylers": [
      { "color": "#C9E7D2"  }
    ]
	},
	{
	"featureType": "all",
	  "elementType": "labels.icon",
    "stylers": [
      { "visibility": "on" }
    ]
	}
]
//const haversine = require('haversine')

import * as firebase from "firebase";
import firestore from '@react-native-firebase/firestore';
import * as geofirestore from 'geofirestore';
import apiKeys from '../config/keys';

if (!firebase.apps.length) {
    console.log('Connected with Firebase')
    firebase.initializeApp(apiKeys.firebaseConfig);
}

const db = firestore();

const GeoFirestore = geofirestore.initializeApp(db);
const geocollection = GeoFirestore.collection('driver_locations');

/*const distance = require('google-distance-matrix');
distance.key('AIzaSyAr2ESV30J7hFsOJ5Qjaa96u9ADSRX6_Sk');
distance.units('imperial');
*/
export default class RideConfirm1 extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
        	step:1,
        	locationcur:{},
        	sourceLocation:{},
        	latitudecur:-33.8688,
        	longitudecur:151.2195,
         latitudedest:'',
        	longitudedest:'',
        	destlocatdesc:'',
        	latitudeDelta: 0.007683038072176629,
         longitudeDelta: 0.004163794219493866,
         origin:{},
          driverCoordinate: new AnimatedRegion({
                latitude: -34.07465730,
                longitude: 151.01108000,
                latitudeDelta: 0.007683038072176629,
                longitudeDelta: 0.004163794219493866,
            }),
         destination:{},
         duration:'',
         servicetypes:[],
         selectedvehicle:{},
         inprocessing:0,
         display:false,
         modalvisible:false,
         distance:'',
         bookingdriver:{},
         driverLocation:{},
         distanceTravelled:'',
         drivertoloccord:{},
         bookingresponse:{},
         rideinfoinprocess:{},
         snaptoval:['62%', '40%'],
         snapIndex:0,
         notadjust:false,
         displaydriveloc:false,
         imagezoom:'',
         vehinfo:{},
         waypointslnglat:[],
         congdone:false,
         selectedcancelchr:0,
         drivernear:{},
         tripstart:false,
         rewardpoints:0,
         selectedvehiclefare:0,
         selectsurcharge:0,
         heading: 0,
         rotateValue: new Animated.Value(0),
         pathHeading:0,
         pathCenter:{},
         min1ack:false,
         min5ack:false,
         min15ack:false,
         messagecount:0,
         
    };
    this.mapView = null;
    this._onLongPressButton = this._onLongPressButton.bind(this);
    this.myinterval = React.createRef();
     this.bottomSheetRef = React.createRef();
    this.settime = React.createRef();
    this.onGoBackCallback = this.onGoBackCallback.bind(this);
    
    this.pusher = new Pusher('389d667a3d4a50dc91a6', { cluster: 'ap2' }); 
    this.listenForChanges(); 
     	
   }
   
   listenForChanges = () => {
		const channel = this.pusher.subscribe('turvy-channel'); 
		 channel.bind('book_aftercancel_event', data => {
		 	this.getrideCancel();
		  //alert(JSON.stringify(data));
		  }); 
		   	//
        	 	 	//
		 channel.bind('tap_to_depart_event', data => {
		 	this.getrideStart();
		 //alert(JSON.stringify(data));
		 });
		  
	};
   
   _onLongPressButton(imagezoom) {
    this.setState({
    	modalvisible:true,
    	imagezoom:imagezoom,
    })
  }
  
   _onPressDone(){
		this.setState({
			modalvisible:false
		});   
   }
   
   renderMessagesDriver = () =>{
    	return (<><View style={{flex:1,alignContent:'center',justifyContent:'center',flexDirection:'row'}}><Text style={{color:'#fff',fontSize:35,padding:3,fontFamily: "Metropolis-Regular",textAlign:'center'}}>Congrats</Text>
    	</View>
    	<View style={{flex:1,alignContent:'center',justifyContent:'center',flexDirection:'row'}}>
    	<Text style={{color:'#fff',fontSize:20,padding:3,fontFamily: "Metropolis-Regular",textAlign:'center'}}>Your driver has arrived</Text></View>
    	</>);
  }
  
  onPlaybackStatusUpdate(PlaybackStatus){
  	console.log(PlaybackStatus);

  		if(PlaybackStatus.didJustFinish == true){
  			console.log("Sound Complete");
  		}
  }
  
  onRegionChangeComplete = (region) => {
        //console.log('onRegionChangeComplete', region);
        console.log("On region change", region);
        this.setState({
            latitudeDelta: region.latitudeDelta,
            longitudeDelta: region.longitudeDelta,
        })
        
        /*this.setState({
            latitudeDelta: 0.007683038072176629,
            longitudeDelta: 0.004163794219493866,
        })
        */
    };
  
  async getrideStart(){
  	  console.log("BOOKING ID "+this.state.bookingresponse.id);
  	  //.where('status','==','open')
  	  //alert(this.state.bookingresponse.id);
  		firestore().collection('trip_path').where('bookingId','==',this.state.bookingresponse.id)
		.get()
		.then(querySnapshot => {
			    console.log('Total bOOKING STATUS: ', querySnapshot.size);
			    
			    if(querySnapshot.size > 0){
			    
			    	clearInterval(this.myinterval);
			    	clearInterval(this.settime);
			    	this.setState({
			    		tripstart:true
			    	},()=>{
			    		this.props.navigation.replace('BookingMap1',this.state);
			    	})
			    //	alert("IN NCONFIRM");
			    }																																																																																																																																															
		});
  }
  
   async getrideCancel(){
		await AsyncStorage.getItem('accesstoken').then((value) => {
  		 	//alert('https://turvy.net/api/rider/requestbookstatus/'+this.state.bookingresponse.id);
      	fetch('https://www.turvy.net/api/rider/requestbookstatus/'+this.state.bookingresponse.id,{
     	  	method: 'GET', 
		   headers: new Headers({
		     'Authorization': 'Bearer '+value, 
		     'Content-Type': 'application/json'
		   }),
		   })
      .then((response) => response.json())
      .then((json) =>{ 
      	//console.log("get status if driver accept");
      	console.log("CANCEL RESPONSE ",json);
      	if(json.message == 'not assigned'){
      			//alert("IN NOT ASSIGNED ");
      			clearInterval(this.myinterval);
		      	clearInterval(this.settime);
		      	this.props.navigation.replace('BookProcess',this.state);
      	}
      	
      	if(json.message == 'cancel'){
      		this.refs.fmcancelInst.showMessage({
		           message: 'Trip Request had been cancelled by Driver!',
		           type: "warning",
		           autoHide:false,
		           style:{
		           		margin:20,
		           		borderRadius:10,
		           		alignItems:'center',
		           		justifyContent:'center'
		           },
		        	 });
		      clearInterval(this.myinterval);
		      clearInterval(this.settime);
      		setTimeout(function(){
      			if(this.refs.fmcancelInst){
			   	  	this.refs.fmcancelInst.hideMessage();
			   	  }
		        	 this.setState({
				    		tripstart:true
			    	 },()=>{
	        	 	 	this.props.navigation.replace('BookMain');
	        	 	 });
        	 	 }.bind(this), 5000);
      	}
      }); 
     }); 	  	
   }
  
  async runsound(){
  		
  		
        	 
  		   const { sound } = await Audio.Sound.createAsync(
		       require('../assets/rider_driver_arriving.mp3'),
		       {},
		       this.onPlaybackStatusUpdate,
		    );
		    //setSound(sound);		
		    console.log('Playing Sound');
		    await sound.playAsync();
		    this.refs.fmLocalIntstance.showMessage({
           message: '',
           type: "default",
           backgroundColor: "#135AA8", 
           autoHide:false,
           style:{
           		margin:20,
           		borderRadius:10,
           		alignItems:'center',
           		justifyContent:'center'
           },
			onPress: ()=>{
				sound.setIsLoopingAsync(false)
				sound.stopAsync();
				
				this.setState({
					congdone:true,
				});
			},
           renderCustomContent: ()=>{
           	return this.renderMessagesDriver();
           },
        	 });
        	 
		    // this.props.navigation.navigate('BookingMap',this.state);
  }   
  
  async run15MinSound(){
		const { sound } = await Audio.Sound.createAsync(
			require('../assets/rider_driver_arriving.mp3'),
			{},
			this.onPlaybackStatusUpdate,
		);
		sound.setIsLoopingAsync(true)
		this.refs.fmLocalIntstance.showMessage({
			message: '',
			type: "default",
			backgroundColor: "#135AA8", 
			autoHide:false,
			style:{
				margin:20,
				borderRadius:10,
				alignItems:'center',
				justifyContent:'center'
			},
			onPress: ()=>{
				sound.setIsLoopingAsync(false)
				sound.stopAsync();
				
				this.setState({
					min15ack:true,
				});
			},
			renderCustomContent: ()=>{
				return this.renderDriverMessage('15');
			},
		});
		
		await sound.playAsync();
		// this.props.navigation.navigate('BookingMap',this.state);
	}

	async run5MinSound(){
		const { sound } = await Audio.Sound.createAsync(
			require('../assets/rider_driver_arriving.mp3'),
			{},
			this.onPlaybackStatusUpdate,
		);
		sound.setIsLoopingAsync(true)
		this.refs.fmLocalIntstance.showMessage({
			message: '',
			type: "default",
			backgroundColor: "#135AA8", 
			autoHide:false,
			style:{
				margin:20,
				borderRadius:10,
				alignItems:'center',
				justifyContent:'center'
			},
			renderCustomContent: ()=>{
				return this.renderDriverMessage('5');
			},
			onPress: ()=>{
				sound.setIsLoopingAsync(false)
				sound.stopAsync();
				this.setState({
					min5ack:true,
				});
			},
		});
		await sound.playAsync();
		// this.props.navigation.navigate('BookingMap',this.state);
	}
	
	render1minDriverMessage = (time) =>{
		return (
			<>
				<View style={{flex:1,alignContent:'center',justifyContent:'center',flexDirection:'row'}}>
					<Text style={{color:'#fff',fontSize:20,padding:3,fontFamily: "Metropolis-Regular",textAlign:'center'}}>Your driver arrives in</Text>
				</View>
				<View style={{flex:1,alignContent:'center',justifyContent:'center',flexDirection:'row'}}>
					<Text style={{color:'#fff',fontSize:25,padding:3,fontFamily: "Metropolis-Regular",textAlign:'center'}}>{time} Minute</Text>
				</View>
				<View style={{flex:1,alignContent:'center',justifyContent:'center',flexDirection:'row'}}>
					<Text style={{color:'#fff',fontSize:25,padding:3,fontFamily: "Metropolis-Regular",textAlign:'center'}}>Please Wave {'\u270B'}</Text>
				</View>
			</>
		);
	}
	
	renderDriverMessage = (time) =>{
		return (
			<>
				<View style={{flex:1,alignContent:'center',justifyContent:'center',flexDirection:'row'}}>
					<Text style={{color:'#fff',fontSize:20,padding:3,fontFamily: "Metropolis-Regular",textAlign:'center'}}>Your driver arrives in</Text>
				</View>
				<View style={{flex:1,alignContent:'center',justifyContent:'center',flexDirection:'row'}}>
					<Text style={{color:'#fff',fontSize:25,padding:3,fontFamily: "Metropolis-Regular",textAlign:'center'}}>{time} Minutes</Text>
				</View>
			</>
		);
	}
	
	async run1MinSound(){
		const { sound } = await Audio.Sound.createAsync(
			require('../assets/rider_driver_arriving.mp3'),
			{},
			this.onPlaybackStatusUpdate,
		);
		sound.setIsLoopingAsync(true)
		this.refs.fmLocalIntstance.showMessage({
			message: '',
			type: "default",
			backgroundColor: "#135AA8", 
			autoHide:false,
			style:{
				margin:20,
				borderRadius:10,
				alignItems:'center',
				justifyContent:'center'
			},
			renderCustomContent: ()=>{
				return this.render1minDriverMessage('1');
			},
			onPress: ()=>{
				sound.setIsLoopingAsync(false)
				sound.stopAsync();
				this.setState({
					min1ack:true,
				});
			},
		});
		await sound.playAsync();
		// this.props.navigation.navigate('BookingMap',this.state);
	}
   
   async getVehcileDetails(driverId){
   	//alert('https://turvy.net/api/driver/getdriverVeh/'+driverId);
   	fetch('https://www.turvy.net/api/driver/getdriverVeh/'+driverId,{
     	  	method: 'GET', 
		   headers: new Headers({
		     'Content-Type': 'application/json'
		   }),
		   })
      .then((response) => response.json())
      .then((json) =>{ 
      	console.log("vehcile Details");
      	console.log(json);
      	
      	if(json.status == 1){
      		this.setState({
      			vehinfo:json.data
      		});
      		
      	}
     	 }
      )
      .catch((error) =>{
      	console.error(error);
      });
      
   }
   
    // Converts from degrees to radians.
    toRadians = (degrees) => {
      return (degrees * Math.PI) / 180;
    }

    // Converts from radians to degrees.
    toDegrees = (radians) => {
      return (radians * 180) / Math.PI;
    }
	
   
    getHeading = (origin, destination) => {
        const originLat = this.toRadians(origin.latitude);
        const originLng = this.toRadians(origin.longitude);
        const destLat = this.toRadians(destination.latitude);
        const destLng = this.toRadians(destination.longitude);

        const y = Math.sin(destLng - originLng) * Math.cos(destLat);
        const x =
        Math.cos(originLat) * Math.sin(destLat) -
        Math.sin(originLat) * Math.cos(destLat) * Math.cos(destLng - originLng);
        const heading = this.toDegrees(Math.atan2(y, x));
        return (heading + 360) % 360;
    }
    
    async updatecarLoc(){

    		//console.log(cords);
    		//const await 
    		this.settime =  setInterval(()=>{ 
    		       //alert(this.props.route.params.bookingdriver.id);
    				var docRef = firestore().collection("driver_locations").doc(JSON.stringify(this.props.route.params.bookingdriver.id));
                docRef.get().then((doc) => {
                    if (doc.exists) {
                        console.log("Document data:", doc.data());
                        this.setState({ driverLocation:doc.data().coordinates,
           					 heading:doc.data().heading },()=>{
           					 	 
					       	console.log(" ORGIN SET ",this.state.driverLocation);      	
					       });
					       /*
					        driverCoordinate: new AnimatedRegion({
					                latitude: doc.data().coordinates.latitude,
					                longitude: doc.data().coordinates.longitude,
					                latitudeDelta: 0.0943,
					                longitudeDelta: 0.0943,
					            }),
					       */
                    } else {
                        // doc.data() will be undefined in this case
                        console.log("No such document!");
                    }
                    
                    let rotateAngl = 0;
                   
                    rotateAngl = (doc.data().heading/360);
                    Animated.timing(this.state.rotateValue, {
			                toValue: rotateAngl,
			                duration: 2000,
			                useNativeDriver: true,
			            }).start();
		            
					
                    
                    const newCoordinate = {
					                latitude: doc.data().coordinates.latitude,
					                longitude: doc.data().coordinates.longitude,
					                latitudeDelta: this.state.longitudeDelta,
					                longitudeDelta: this.state.longitudeDelta,
					            };
					            
					
					
					            if (this.marker) {
					                //console.log('newCoordinate',newCoordinate)                
					                this.state.driverCoordinate.timing({ ...newCoordinate, useNativeDriver: true,duration: 4000 }).start();
					            }
					      if(this.mapView) {
				            this.mapView.animateCamera({
				                center:{
				                    latitude: doc.data().coordinates.latitude,
				                    longitude: doc.data().coordinates.longitude,
				                }
				            });
				        }
				        
				        
					            
					            
                }).catch((error) => {
                    console.log("Error getting document:", error);
                });
			  }, 4000);						
    }	
   	 
    componentDidMount(){
    	const {navigation,state} = this.props;
			
       console.log("DRIVER Details ",this.props.route.params.bookingdriver);
       console.log("Booking Details ",this.props.route.params.bookingresponse);
        	// alert(Object.keys(this.state.driverLocation).length);
        	// alert(Object.values(this.state.driverLocation).length);
        	// alert(Object.entries(this.state.driverLocation).length);
     
       BackHandler.addEventListener('hardwareBackPress', this.onGoBackCallback);
        navigation.addListener('gestureEnd', this.onGoBackCallback);
        
		// this.getrewards();
		this.unsubscribe =  navigation.addListener("focus",() => {
			BackHandler.addEventListener('hardwareBackPress', this.onGoBackCallback);
       	navigation.addListener('gestureEnd', this.onGoBackCallback);
      });
      this.unsubscribeblur =  navigation.addListener("blur",() => {
      	//clearInterval(this.myinterval);
         // clearInterval(this.myintervalaccp);
      	BackHandler.removeEventListener('hardwareBackPress', this.onGoBackCallback);
      });
      
      console.log("compoente mount");
   	
   	console.log(state);
  
   	console.log("CONS DATA",this.props.route.params.bookingdriver);
      if(this.props.route.params.selectedvehicle){
      	this.getVehcileDetails(this.props.route.params.bookingdriver.id);
      	this.setState({ 
             selectedvehicle:this.props.route.params.selectedvehicle,
             origin:this.props.route.params.origin,
             destination:this.props.route.params.destination,
             latitudedest:this.props.route.params.latitudedest,
             longitudedest:this.props.route.params.longitudedest,
             latitudecur:this.props.route.params.latitudecur, 
             longitudecur:this.props.route.params.longitudecur,
             bookingresponse:this.props.route.params.bookingresponse,
             rideinfoinprocess:this.props.route.params.rideinfoinprocess,
             bookingdriver:this.props.route.params.bookingdriver,
             waypointslnglat:this.props.route.params.waypointslnglat,
             selectedcancelchr:this.props.route.params.selectedcancelchr,
             selectedvehiclefare:this.props.route.params.selectedvehiclefare,
             selectsurcharge:this.props.route.params.selectsurcharge,
             driverCoordinate: new AnimatedRegion({
	                latitude: this.props.route.params.origin.latitude,
	                longitude: this.props.route.params.origin.longitude,
	                latitudeDelta: 0.0943,
	                longitudeDelta: 0.0943,
	            }),
        },
        ()=>{
        	   
       // 	alert(this.state.latitudecur);
       // 	alert(this.state.longitudecur);
        	 //console.log(this.props.route.params.bookingdriver);
				console.log("STATE SET");
        	//alert(this.props.route.params.bookingdriver.id);
        	
        });
      }else if(this.props.route.params.bookingdriver.id > 0){
      	//alert(this.props.route.params.bookingdriver.id);
      	this.getVehcileDetails(this.props.route.params.bookingdriver.id);
      	this.setState({
      		origin:this.props.route.params.origin,
             destination:this.props.route.params.destination,
             latitudedest:this.props.route.params.latitudedest,
             longitudedest:this.props.route.params.longitudedest,
             latitudecur:this.props.route.params.latitudecur, 
             longitudecur:this.props.route.params.longitudecur,
             bookingdriver:this.props.route.params.bookingdriver,
             bookingresponse:this.props.route.params.bookingresponse,
             waypointslnglat:this.props.route.params.waypointslnglat,
              driverCoordinate: new AnimatedRegion({
	                latitude: this.props.route.params.origin.latitude,
	                longitude: this.props.route.params.origin.longitude,
	                latitudeDelta: 0.0943,
	                longitudeDelta: 0.0943,
	            }),
      	},()=>{
      		//
      	});
      
      }
      
      //this.getdriversnear();
      
      this.getRewards();	
      	AsyncStorage.getItem('messagecount').then((value) => {           
            if(value != '' && value !== null){
                this.setState({messagecount:value})
                //alert(value)
            }
        });	 
		 
     // alert("DRUVER ID "+this.props.route.params.bookingdriver.id);
      var docRef = firestore().collection("driver_locations").doc(JSON.stringify(this.props.route.params.bookingdriver.id));
                docRef.get().then((doc) => {
                    if (doc.exists) {
                        console.log("Document data INITAL 1 :", doc.data());
                        this.setState({driverLocation:doc.data().coordinates,
                         driverCoordinate: new AnimatedRegion({
					                latitude: doc.data().coordinates.latitude,
					                longitude: doc.data().coordinates.longitude,
					                latitudeDelta: 0.0943,
					                longitudeDelta: 0.0943,
					            }),
					            heading:doc.data().heading,
                        displaydriveloc:true},()=>{
                        	
                        	const center = {
                                  latitude: (this.state.origin.latitude + this.state.destination.latitude) / 2,
                                  longitude: (this.state.origin.longitude + this.state.destination.longitude) / 2,
                                };
                                console.log("source dest center",center);
                                const destheading = this.getHeading(this.state.origin, this.state.destination)
                                console.log('dest heading',destheading)
                                this.setState({
                                    pathHeading:destheading,
                                    pathCenter:center
                                })
					       	 console.log(" ORGIN SET INITAL "+JSON.stringify(this.state.driverLocation));      	
					       });
                    } else {
                        // doc.data() will be undefined in this case
                        console.log("No such document!");
                    }
                }).catch((error) => {
                    console.log("Error getting document:", error);
                });
     
                
    
        
   	this.intialLoad();

   	this.refs.fmLocalIntstance.showMessage({
           message: '',
           type: "default",
           backgroundColor: "#135AA8", 
           autoHide:false,
           style:{
           		margin:20,
           		borderRadius:10,
           		alignItems:'center',
           		justifyContent:'center'
           },
          
           renderCustomContent: ()=>{
           	return this.renderMessages();
           },
        	 });
        	 
        	this.getrideStart();
        	 this.getrideCancel();
        	 
        	 /*this.myinterval = setInterval(() => {
        	 	 if(this.state.tripstart == false){
        	 	 	
        	 	 }	  				
           }, 5000);
           */
            	  			
     	
  } // end of function
 
   onGoBackCallback(){
      console.log('Android hardware back button pressed and iOS back gesture ended');
      this.setState({
      	modalvisible:true
      });
      this.props.navigation.replace('BookMain',this.state);
     return true;
   }
   
  async getRewards(){
		 await AsyncStorage.getItem('rewardpoints').then((value) => {
			this.setState({
				rewardpoints:value,
			});
		});	    
  }
  async getdriversnear(){
   let search_radius = await AsyncStorage.getItem('search_radius');
  	const query = geocollection.near({ center: new firestore.GeoPoint(this.state.latitudecur,this.state.longitudecur ), radius: Number(search_radius)});
		 //.where('isBusy','==','no')
		 const accesstoken = await AsyncStorage.getItem('accesstoken');
			// Get query (as Promise)
		query.get().then((value) => {
		  // All GeoDocument returned by GeoQuery, like the GeoDocument added above
		  console.log("IN QUERY");
		  console.log(value.docs);
		  const drivernear = [];
		   value.docs.map((item, index) => {
		   	 console.log("DRIVER MAP");
		   		 console.log(item.data().coordinates);
		   	if(item.exists == true){
		   			drivernear.push({['coordinates']:item.data().coordinates,
				      	['driverId']:item.id,	});
				      this.setState({
	      			drivernear:drivernear,
	      		},()=>{
	      			console.log(this.state.drivernear);
	      		});
		   	}
		   });
		 });
		 
  }
   renderMessagesreward = () =>{
    	return (<View style={{flex:1,alignContent:'center',justifyContent:'center',flexDirection:'column',shadowColor: '#000000',
    shadowOffset: {
      width: 1,
      height: 3
    },
    shadowRadius: 5,
    shadowOpacity: 1.0}} elevation={5}>
    	<View style={{width:150,height:46,backgroundColor: "#135AA8",flexDirection:'row',borderTopLeftRadius:10,borderTopRightRadius:10,alignContent:'center',justifyContent:'center' }}>
    		<Text style={{color:'#DCAC4B',fontSize:20,padding:3,fontFamily: "Metropolis-Regular",textAlign:'center',fontWeight:'bold'}}>22</Text>
      </View>
      <View style={{width:150,backgroundColor:'#fff',flexDirection:'row',justifyContent:'center',flexDirection:'column'}}>
    	<Text style={{color:'#000',fontSize:15,padding:3,fontFamily: "Metropolis-Regular",textAlign:'center'}}>Reward Points</Text>
    	 </View>
    	</View>);
  }
  
   
   openDialScreen (){
    let number = '';
    //alert("CALL click	");
    fetch('https://www.turvy.net/api/rider/twiliomakecallrider',{
				     	  	method: 'POST', 
						   headers: new Headers({
						     'Content-Type': 'application/json'
						   }), 
						   body:JSON.stringify({
					 				'driver_id' : this.state.bookingdriver.id,
					 				'booking_id' : this.state.bookingresponse.id,
					 				'first_name' : this.state.bookingdriver.first_name,
					 				'last_name' : this.state.bookingdriver.last_name,
					 				'mobile' : this.state.bookingdriver.mobile,
					 				'rider_phone' : this.state.bookingresponse.rider_mobile,
					 				'rider_name' : this.state.bookingresponse.rider_name,
					 				'rider_id': this.state.bookingresponse.rider_id,
					 			}) 
						   })
				      .then((response) => response.json())
				      .then((json) =>{ 
				      	//console.log("RESPONSE CALL 1",json);
				      	
				      	//alert("IN SUCCESS"+json.senderphn);
				         if (Platform.OS === 'ios') {
							      number = 'telprompt:${'+json.senderphn+'}';
							    } else {
							      number = 'tel:${'+json.senderphn+'}';
							    }
                       Linking.openURL(number);
				      	/*if(json.status == 1){
				      		 this.setState({                                        
					         	isLoading:false,
				    				vehborder:'red',
				    				bookingresponse:json.data
					         });
				      		this.props.navigation.navigate('PromoCode',this.state)
				      	}
				      	*/
				     	 }
				      )
				      .catch((error) => { console.error(" CALL ERROR BLOCK" ,error) });
  }
  
  renderMessages = () =>{
    	return (<View style={{flex:1,alignContent:'center',justifyContent:'center',flexDirection:'row'}}><Text style={{color:'#fff',fontSize:20,padding:3,fontFamily: "Metropolis-Regular",textAlign:'center'}}>Your driver arrives in {this.state.duration} minutes</Text></View>);
  }
    
  UNSAFE_componentWillUnmount() {
    //this.unsubscribe();
    if(this.settime){
    	clearInterval(this.settime);
    }
    if(this.myinterval){
      clearInterval(this.myinterval);
    }
   
  }
 
	swipicon =() =>{
		return(<Ionicons name="ios-close-outline" size={40} color="black" />)
	} 
	
    renderContent = () => (
    <>
    <View
      style={{
        backgroundColor: 'white',
        padding: 16,
        height: '100%',
        margin:10,
        shadowColor: "#000",
		  shadowOffset: {
				width: 0,
				height: 2,
			},
			shadowOpacity: 0.23,
			shadowRadius: 2.62,
			elevation: 4,
			borderRadius:10,
      }}
    >
  
    {this.state.inprocessing == 0  ? 
   	( <Grid >
   			<Row style={{height:120}}>
   				
   				<Col size={3.5} style={{padding:3}}>
   				<TouchableHighlight onLongPress={()=>{ this._onLongPressButton(this.state.bookingdriver.avatar) }} underlayColor="white">
   				<View style={{height:100,borderRadius:8}}>																				
						{this.state.bookingdriver.avatar ? 
							(<Image
				        source={{uri:"https://www.turvy.net/"+this.state.bookingdriver.avatar}}
				        style={styles.servicebocimage}
				        Resizemode={'contain'}
				         />)
							:
							(<Image
				        source={{uri:"https://www.turvy.net/images/no-person.png"}}
				        style={styles.servicebocimage}
				        Resizemode={'contain'}
				         />)
						}
   					
   				</View>
   				</TouchableHighlight>
   				</Col>
   				<Col size={6} style={{padding:3}}>
   					<Text style={{fontSize:18,color:'#135AA8',fontWeight:'bold'}}>{this.state.bookingdriver.first_name} {this.state.bookingdriver.last_name}</Text>
   					<Text style={{fontSize:12,fontWeight:'bold',color:'#135AA8'}}>Car Rego: {this.state.vehinfo.plate ? this.state.vehinfo.plate : ''}</Text>
   					<Text style={{fontSize:12,fontWeight:'bold',color:'#135AA8'}}>{this.state.vehinfo.makename ? this.state.vehinfo.makename : ''} : {this.state.vehinfo.modelname ? this.state.vehinfo.modelname : ''} </Text>
   					<Text style={{fontSize:12,fontWeight:'bold',color:'#135AA8'}}>{this.state.vehinfo.color ? this.state.vehinfo.color : ''}</Text>
   					<Text style={{fontSize:12,fontWeight:'bold',color:'#135AA8'}}>{this.state.selectedvehicle.name}</Text>
   				</Col>
   				<Col size={4} style={{padding:3}}>
   				 <TouchableHighlight onLongPress={()=>{ this._onLongPressButton(this.state.vehinfo.front_photo) }} underlayColor="white">
   				<View style={{height:100,padding:10,borderRadius:8}}>
   				 {this.state.vehinfo.front_photo ?
   					(<Image
				        source={{uri:"https://www.turvy.net/"+this.state.vehinfo.front_photo}}
				        style={styles.servicebocimage}
				        Resizemode={'contain'}
				         />
				         )
				         :null
				    }
				    </View>
				    </TouchableHighlight>
   				</Col>
   			</Row>
   			<Row style={{height:60}}>
   			<Col size={1.5}>
   				</Col>
   				<Col size={3} style={{margin:8,height:55}}>
   					<View style={{flex:1,backgroundColor:'#62CD32',alignItems:'center',justifyContent:'center',width:'90%',borderRadius:5}} >
   					<TouchableOpacity onPress={() => this.openDialScreen()}>
   					<Feather name="phone-call" size={18} color="white" />
   					<Text style={{color:'#fff'}}>
   						Call
   					</Text>
   					</TouchableOpacity>
   					</View>
   				</Col>
   				<Col size={3} style={{alignItems:'center',justifyContent:'center',margin:8,height:55}}>
   				<View style={{flex:1,backgroundColor:'#EA202A',alignItems:'center',justifyContent:'center',width:'90%',alignContent:'center',borderRadius:5}}>
   				   <TouchableOpacity onPress={() =>{this.props.navigation.navigate('BookCancel',this.state) }}>
   					<AntDesign name="closecircleo" size={18} color="white"  style={{textAlign:'center'}} />
   					<Text style={{color:'#fff'}}>
   						Cancel		
   					</Text>	
   					</TouchableOpacity>
   					</View>
   				</Col>
   				<Col size={3} style={{alignItems:'flex-end',margin:8,height:55}}>
   				<View style={{flex:1,backgroundColor:'#135AA8',alignItems:'center',justifyContent:'center',width:'90%',borderRadius:5}}>
   					<MaterialCommunityIcons name="dots-horizontal-circle-outline" size={24} color="white" />
   					<Text style={{color:'#fff'}}>
   						More
   					</Text>
   					</View>
   				</Col>
   				<Col size={1.5}>
   				</Col>
   			</Row>
   			<Row style={{height:20,padding:6,marginTop:20}}>
   				<Col size={1}>
   					<View style={styles.inforound}>
   						<MaterialCommunityIcons name="information-variant" size={20} color="black" />
   					</View>
   				</Col>
   				<Col size={11}>
   				<Text style={{color:'#3f78ba',fontWeight:'bold',fontSize:15}}>  Long press on image to zoom in</Text>
   				</Col>
   			</Row>
   		</Grid>
       ):(
       	<Text></Text>
       )
      } 
    </View>
   </>
  );   
  
  
  async intialLoad() {
  	
    
     let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
       // setErrorMsg('Permission to access location was denied');
        return;
      }
      /*let location = await Location.getCurrentPositionAsync();
       //console.log(location.coords.latitude);
       //console.log(location.coords.longitude);
       const latitudeDelta = location.coords.latitude-location.coords.longitude;
       const longitudeDelta = latitudeDelta * ASPECT_RATIO;
       */
        //console.log(latitudeDelta);
       //console.log(longitudeDelta);
       let origin ={};
      // console.log(this.props.route.params.destination);
      if(this.props.route.params.origin){
       	 origin = this.props.route.params.origin;
		}      
		let destination = {};
		let longitudedest = '';
		let latitudedest= '';
		if(this.props.route.params.destination){
			destination = this.props.route.params.destination;
			longitudedest = destination.longitude;
			latitudedest = destination.latitude;
		}
      let selectedvehicle = {};
      console.log(this.props.route.params.selectedvehicle);
      if(this.props.route.params.selectedvehicle){
      	selectedvehicle = this.props.route.params.selectedvehicle;
      }
      
      this.setState({
      	selectedvehicle:selectedvehicle,
      });
      /*this.setState({
      	locationcur:location,
      	latitudecur:location.coords.latitude,
      	longitudecur:location.coords.longitude,
      	latitudeDelta:0.00176,
      	longitudeDelta:0.00176,
      	origin:origin,
      	destination:destination,
      	latitudedest:latitudedest,
      	longitudedest:longitudedest,
      	selectedvehicle:selectedvehicle,
      });
      */
      //console.log(location);
     /*
       if (location.coords) {
		    const { latitude, longitude } = location.coords;
		      let keys = {
		        latitude : latitudedest,
		        longitude : longitudedest
		    }
		   /* let response = await Location.reverseGeocodeAsync(keys);
		    
		     //console.log(response);
		    
		   let address = '';
		    for (let item of response) {
		    	//${item.street}, 
		      let address = `${item.name}, ${item.postalCode}, ${item.city}`;
		       //console.log(address);
		       this.setState({
		      	destlocatdesc:address,
		      });
		    }
		    */
		 // }
		  
      //.finally(() => setLoading(false));
    }
    
  render() {
  	let rotateAngl = 0;
   rotateAngl = (this.state.heading/360);
  	const spin = this.state.rotateValue.interpolate({
          inputRange: [0, 1],
          outputRange: ['0deg', '360deg']
        })
  	 return (
	    <View style={styles.container}>  
	   	 <TopBar {...this.props} />
       <FlashMessage ref="fmLocalIntstance" position={{top:80, left:10,right:10}} style={{borderRadius:2}}  />
       <FlashMessage ref="fmcancelInst" position={{top:130}} style={{borderRadius:2}}  />
     <MapView.Animated style={styles.map}
       initialRegion={{latitude: this.state.latitudecur,
         longitude: this.state.longitudecur,
         latitudeDelta: this.state.latitudeDelta,
         longitudeDelta: this.state.longitudeDelta,}}
        onRegionChangeComplete={this.onRegionChangeComplete}
       customMapStyle={stylesArray}  
        ref={c => this.mapView = c}
       onPress={ (e) => {                            
             this.setState({
                 snapIndex: this.state.snapIndex ? 0 : 1
             },() => {                                        
                 this.bottomSheetRef.current.snapTo(this.state.snapIndex)    
             })
             
         }}
    
       >	
      
     { this.state.driverLocation && Object.keys(this.state.driverLocation).length > 0 && this.state.driverLocation.latitude && this.state.driverLocation.longitude ?  	 
     	  (<MapView.Marker.Animated
			    key={'driverloc'}
			     ref={marker => {this.marker = marker;}}
			      coordinate={this.state.driverCoordinate} 
			      anchor={{ x: 0.5, y: 0.5 }}
               flat
			    >
			    <Animated.Image
			        source={imageveh}
			        style={{
                       width: 40,
					    		height:40,
								 alignSelf:'center',
                       transform: [{rotate: spin}]
                   }}
                   resizeMode="contain" />
			   </MapView.Marker.Animated>)
			:
			null	
     }
        
    {Object.keys(this.state.waypointslnglat).length > 0 ?
    this.state.waypointslnglat.map((item, key) => {
    	return(
    	<MapView.Marker.Animated
			    key={key}
			      coordinate={{latitude: item.latitude,longitude: item.longitude}}  >
    		<Entypo name="location-pin" size={30} color="green" />
    	 </MapView.Marker.Animated>
    	)
	 }) 
	 :null
   }
     { Object.keys(this.state.origin).length > 0 && Object.keys(this.state.driverLocation).length > 0 ?
    (
    <>
    	<MapViewDirections
    	region={'AU'}
    origin={this.state.driverLocation}
    destination={this.state.origin}
    strokeWidth={5}
    lineDashPattern={[1]}
      strokeColor="#5588D9"
      apikey="AIzaSyAr2ESV30J7hFsOJ5Qjaa96u9ADSRX6_Sk"
      lineCap={'butt'}
      lineJoin={'miter'}
       mode={"DRIVING"}
      onStart={(params) => {
              console.log(`Started routing between "${params.origin}" and "${params.destination}"`);
             
            }}
      onReady={result => {
      			//console.log(result);
              //console.log(`Distance: ${result.distance} km`)
              //console.log(`Coorinates: ${result.coordinates} km`)
              console.log(`Duration: ${result.duration} min.`)
              let duration = result.duration.toFixed();
              let distance = result.distance;
              // find amount to display 
             
 				if(duration == 15 && this.state.min15ack == false){
						this.run15MinSound()
					}
					if(duration == 5 && this.state.min5ack == false){
						this.run5MinSound()
					}
					if(duration == 1 && this.state.min1ack == false){
						this.run1MinSound()
					}
								
									
				  if(duration == 0){
				  	if(this.state.congdone == false){
				  		this.runsound();
				  		/*this.setState({
				  			congdone:true,
				  		},()=>{
				  			
				  		});
				  		*/		
				  	}
				  }

             const  distancecal = distance/2;
		        const circumference = 40075;
		        //const oneDegreeOfLatitudeInMeters = 111.32 * 1000;
		        const oneDegreeOfLatitudeInMeters = distancecal*4;
		        const angularDistance = distancecal/circumference;

        		  const latitudeDelta = distancecal / oneDegreeOfLatitudeInMeters;
        		  const longitudeDelta = Math.abs(Math.atan2(
                Math.sin(angularDistance)*Math.cos(this.state.latitudedest),
                Math.cos(angularDistance) - Math.sin(this.state.latitudedest) * Math.sin(this.state.latitudedest)))

              console.log(this.state.drivertoloccord);
              this.setState({
              	duration:duration,
              	distance:distance,
              	display:true,
              	drivertoloccord:result.coordinates
              },()=>{
              	//console.log("before fit");
              		
              	if(this.state.notadjust == false){
              	 /*this.mapView.fitToCoordinates(result.coordinates, {
                edgePadding: {
	                  right: DEVICE_WIDTH*0.20,
			            left:  DEVICE_WIDTH*0.20,
			            top: DEVICE_HEIGHT*0.20,
			            bottom: DEVICE_HEIGHT*0.38	,
	                },
	                   animated: false,
	              });
	              */
	              
	              this.setState({
	              	notadjust:true,
	              });
             	 this.updatecarLoc();
              	}
              	console.log("HEADING MAP",this.state.pathHeading);
              	this.mapView.animateCamera({
                   heading: this.state.pathHeading,
               });
    				
    	     });
              
            }}
  			/>
  		</>
    )
    	:
    	(
    	<>
    	</>
    	)
    } 
    
    
    { Object.keys(this.state.origin).length > 0 && Object.keys(this.state.destination).length > 0 ?
    (
    <>
    	<MapViewDirections
    	region={'AU'}
    origin={this.state.origin}
    destination={this.state.destination}
     waypoints={this.state.waypointslnglat}
    strokeWidth={5}
    lineDashPattern={[1]}
      strokeColor="#000000"
      apikey="AIzaSyAr2ESV30J7hFsOJ5Qjaa96u9ADSRX6_Sk"
      lineCap={'butt'}
      lineJoin={'miter'}
       mode={"DRIVING"}
      onStart={(params) => {
              console.log(`Started routing between "${params.origin}" and "${params.destination}"`);
             
            }}
      onReady={result => {
      		
              	if(this.state.notadjust == false){
              	 this.mapView.fitToCoordinates(result.coordinates, {
                edgePadding: {
	                  right: DEVICE_WIDTH*0.20,
			            left:  DEVICE_WIDTH*0.20,
			            top: DEVICE_HEIGHT*0.20,
			            bottom: DEVICE_HEIGHT*0.38	,
	                },
	                   animated: true,
	              });
	              
	              this.setState({
	              	notadjust:true,
	              });
             	 this.updatecarLoc();
              	}
    				
              
            }}
  			/>
  		</>
    )
    	:
    	(
    	<>
    	</>
    	)
    } 
    
   																																																																																																																																																																																																																																																																																																																																																																																																							
    <Marker
       	tracksViewChanges={false}
      key={'destinationkey'}
      coordinate={{latitude:this.state.latitudecur, longitude:this.state.longitudecur}} 
      
      style={{ alignItems: "center"}} >
       <FontAwesome5 name="map-marker-alt" size={30} color={"#135AA8"} />
     </Marker>
    <Marker
       	tracksViewChanges={false}
      key={'ultidest'}
      coordinate={{latitude:this.state.latitudedest, longitude:this.state.longitudedest}} 
      style={{ alignItems: "center"}} >
       <FontAwesome5 name="map-marker-alt" size={30} color={"#910101"} />
     </Marker>
   
   
  </MapView.Animated>
  { this.state.display ? (
  <BottomSheet
        ref={this.bottomSheetRef}
        snapPoints={this.state.snaptoval}
        borderRadius={20}
        renderContent={this.renderContent}
        overdragResistanceFactor={0}
        enabledManualSnapping={false}
         enabledContentTapInteraction={false}
        enabledContentGestureInteraction={false}
        initialSnap={this.state.snapIndex}
      />)
      :(
      	<Text></Text>
      )
    }
    <Modal
          animationType="slide"
          transparent={true}
          visible={this.state.modalvisible}
          onRequestClose={() => {
            alert('Modal has been closed.');
          }}>
        
          <Grid style={{justifyContent:'center',alignContent:'center'}}>
          	<Row size={5}>
          		<Col>
          		</Col>
          	</Row>
          	<Row size={40} style={{justifyContent:'center',alignContent:'center'}}>
          		<Col style={{justifyContent:'center',alignContent:'center',alignItems:'center'}}>
          		  <View style={{backgroundColor:'#135AA8',height:'100%',width:'80%',justifyContent:'center',alignContent:'center',padding:10,borderRadius:5,}}>
              <Image
				        source={{uri:"https://www.turvy.net/"+this.state.imagezoom}}
				        style={styles.servicebocimage}
				        Resizemode={'contain'}
				         />
            </View>
          		</Col>
          	</Row>
          	<Row size={10} style={{marginTop:10}}>
          		<Col size={4}>
          		</Col>
          		<Col size={4}>
          		 <Button  mode="contained" color={'#135AA8'} onPress={() => this._onPressDone()}>
						    Done
				    </Button>
          		</Col>
          		<Col size={4}>
          		</Col>
          	</Row>
          	<Row size={40}>
          		<Col>
          		</Col>
          	</Row>
          </Grid>
        </Modal>
        <View>
        <CancelPop  {...this.props}  />
        </View>
  </View>	
	  );
   }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
  map: {
    width: Dimensions.get('window').width,
    height: '100%',
  },
  tinyLogo:{
  	alignContent:'center',
  	height:50,
  	flex:1,
  	flexDirection:'row'
  },
  servicesbox:{
  	flexDirection:'column',
 	flex:1,
 	width:150,
 	height:150,
 	backgroundColor:'#e5e5e5',
 	borderWidth:1,
 	borderColor:'#e5e5e5',
 	padding:10,
 	margin:10,
 	alignItems:'center',
 	borderRadius:10,
 	justifyContent:'center'
  },
  servicebocimage:{
    width: '100%',
    aspectRatio: 1,
	 resizeMode: 'contain'
	},
	inforound:{
       borderWidth:2,
       borderColor:'#000',
	    width: 24,
	    height: 24,
	    zIndex: 10,
       alignItems:'center',
       justifyContent:'center',
       backgroundColor:'#fff',
       borderRadius:50,
     },
     yellow:{color:'#fec557'},
btnSmall:{
		backgroundColor:'#3f78ba',
		borderWidth:5,
		borderColor:'#FFF',
		fontSize:50,
		shadowColor: '#000',
	},
     menubox:{
	       borderWidth:1,
	       borderColor:'rgba(0,0,0,0.2)',
			position: 'absolute',
		    width: 45,
		    height: 45,
		    top: 0,
		    left: 10,
		    zIndex: 10,
	       alignItems:'center',
	       justifyContent:'center',
	       backgroundColor:'#fff',
	       shadowColor: "#000",
			shadowOffset: {
				width: 0,
				height: 3,
			},
			shadowOpacity: 0.27,
			shadowRadius: 4.65,
			
			elevation: 6,
	     },
	serachbox:{
		   borderWidth:0,
	       borderColor:'#135aa8',
		    width: 50,
		    height: 50,
	       alignItems:'center',
	       justifyContent:'center',
	       backgroundColor:'#fff',
	       borderRadius:25,
	        shadowColor: "#000",
			shadowOffset: {
				width: 0,
				height: 3,
			},
			shadowOpacity: 0.27,
			shadowRadius: 4.65,
			elevation: 6,
	},
	vehmarkerimage:{
    width: 20,
    height:35,
	 alignSelf:'center'
	},
});
